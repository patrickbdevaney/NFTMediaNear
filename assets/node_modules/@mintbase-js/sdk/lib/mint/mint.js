"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mint = void 0;
const config_1 = require("../config/config");
const constants_1 = require("../constants");
const errorMessages_1 = require("../errorMessages");
const types_1 = require("../types");
/**
 * Mint a token given via reference json on a given contract with a specified owner, amount of copies as well and royalties can be specified via options
 * @param mintArguments {@link MintArgs}
 * @returns contract call to be passed to @mintbase-js/sdk execute method
 */
const mint = (args) => {
    var _a;
    const { contractAddress = config_1.mbjs.keys.contractAddress, metadata, ownerId, royalties, amount, tokenIdsToMint, noMedia = false, noReference = false, } = args;
    if (contractAddress == null) {
        throw new Error(errorMessages_1.ERROR_MESSAGES.CONTRACT_ADDRESS);
    }
    // Reference and media need to be present or explicitly opted out of
    if (!noReference && !metadata.reference) {
        throw new Error(errorMessages_1.ERROR_MESSAGES.NO_REFERENCE);
    }
    if (!noMedia && !metadata.media) {
        throw new Error(errorMessages_1.ERROR_MESSAGES.NO_MEDIA);
    }
    let adjustedRoyalties;
    let royaltyTotal;
    let roundedRoyalties;
    //royalties adjustments to make devx better
    if (royalties) {
        royaltyTotal = getRoyaltyTotal(royalties);
        adjustedRoyalties = adjustRoyaltiesForContract(royalties, royaltyTotal);
        roundedRoyalties = roundRoyalties(adjustedRoyalties);
    }
    //if royalties exist they need to be populated
    if (royalties && Object.keys(royalties).length < 1) {
        throw new Error(errorMessages_1.ERROR_MESSAGES.MIN_ROYALTIES);
    }
    //must not have more than 50 royalty owners
    if (royalties && Object.keys(royalties).length > 50) {
        throw new Error(errorMessages_1.ERROR_MESSAGES.MAX_ROYALTIES);
    }
    //if specifying tokenIdsToMint these must be populated
    if (tokenIdsToMint && tokenIdsToMint.length == 0) {
        throw new Error(errorMessages_1.ERROR_MESSAGES.EMPTY_TOKEN_IDS);
    }
    if (tokenIdsToMint && amount && (tokenIdsToMint === null || tokenIdsToMint === void 0 ? void 0 : tokenIdsToMint.length) !== amount) {
        throw new Error(errorMessages_1.ERROR_MESSAGES.MUTUAL_EXCLUSIVE_AMOUNT);
    }
    //if no amount or tokenids defined then default to 1 amount
    const adjustedAmount = (tokenIdsToMint === null || tokenIdsToMint === void 0 ? void 0 : tokenIdsToMint.length) || amount || 1;
    if (adjustedAmount > 125 || adjustedAmount < 1) {
        throw new Error(errorMessages_1.ERROR_MESSAGES.INVALID_AMOUNT);
    }
    return {
        contractAddress: contractAddress || config_1.mbjs.keys.contractAddress,
        args: {
            owner_id: ownerId,
            metadata: metadata,
            num_to_mint: adjustedAmount,
            // 10_000 = 100% (see above note)
            royalty_args: !royaltyTotal ? null : { split_between: roundedRoyalties, percentage: Math.round(royaltyTotal * 10000) },
            token_ids_to_mint: !tokenIdsToMint ? null : tokenIdsToMint,
        },
        methodName: types_1.TOKEN_METHOD_NAMES.MINT,
        gas: constants_1.GAS,
        deposit: mintingDeposit({
            nSplits: 0,
            nTokens: adjustedAmount,
            nRoyalties: !royalties ? 0 : (_a = Object.keys(royalties)) === null || _a === void 0 ? void 0 : _a.length,
            metadata,
        }),
    };
};
exports.mint = mint;
function getRoyaltyTotal(royalties) {
    let royaltyTotal = 0;
    Object.values(royalties).forEach(value => {
        royaltyTotal += value;
    });
    if (royaltyTotal <= 0 || royaltyTotal > 0.5) {
        throw new Error(errorMessages_1.ERROR_MESSAGES.INVALID_ROYALTY_PERCENTAGE);
    }
    return royaltyTotal;
}
function adjustRoyaltiesForContract(royalties, royaltyTotal) {
    let counter = 0;
    const result = {};
    Object.keys(royalties).forEach(key => {
        if (royalties[key] <= 0) {
            throw new Error(errorMessages_1.ERROR_MESSAGES.NEGATIVE_ROYALTIES);
        }
        const adjustedAmount = royalties[key] / royaltyTotal * 10000;
        result[key] = adjustedAmount;
        counter += adjustedAmount;
    });
    if (counter != 10000) {
        throw new Error(errorMessages_1.ERROR_MESSAGES.ROYALTIES_PERCENTAGE);
    }
    return result;
}
function roundRoyalties(royalties) {
    let roundedCounter = 0;
    const result = {};
    const firstKey = Object.keys(royalties)[0];
    Object.keys(royalties).forEach((key) => {
        const roundedVal = Math.round(royalties[key]);
        result[key] = roundedVal;
        roundedCounter += roundedVal;
    });
    if (roundedCounter != 10000) {
        result[firstKey] += 10000 - roundedCounter;
    }
    return result;
}
function mintingDeposit({ nTokens, nRoyalties, nSplits, metadata, }) {
    const nSplitsAdj = nSplits < 1 ? 0 : nSplits - 1;
    const bytesPerToken = constants_1.STORAGE_BYTES.TOKEN_BASE + nSplitsAdj * constants_1.STORAGE_BYTES.COMMON;
    const metadataBytesEstimate = JSON.stringify(metadata).length;
    const totalBytes = constants_1.STORAGE_BYTES.MINTING_BASE +
        constants_1.STORAGE_BYTES.MINTING_FEE +
        metadataBytesEstimate +
        bytesPerToken * nTokens +
        constants_1.STORAGE_BYTES.COMMON * nRoyalties;
    return `${Math.ceil(totalBytes)}${'0'.repeat(constants_1.STORAGE_PRICE_PER_BYTE_EXPONENT)}`;
}
//# sourceMappingURL=mint.js.map