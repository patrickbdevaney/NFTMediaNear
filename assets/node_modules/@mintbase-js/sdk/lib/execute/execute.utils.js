"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateSigningOptions = exports.flattenArgs = exports.convertGenericCallToWalletCall = exports.genericBatchExecute = exports.callbackUrlFormatter = exports.checkCallbackUrl = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const errors_1 = require("../errors");
/**
 * checkCallbackUrl()
 * method to check if its a regular browser wallet or a InjectedWallet, and make them have the same behavior (redirect) to the desired url.
 * @param callbackUrl url that should redirect after transaction
 * @param callbackArgs metadata that should be passed via url to the success page
 * @returns an outcome object or an array of outcome objects if batching calls {@link FinalExecutionOutcome[]} | {@link FinalExecutionOutcome}, or a redirect to selected callbackUrl
 */
const checkCallbackUrl = (callbackUrl, callbackArgs, wallet, outcomes) => {
    var _a, _b;
    const browserWallets = ['my-near-wallet', 'near-wallet'];
    const isNotBrowserWallet = !browserWallets.includes(wallet === null || wallet === void 0 ? void 0 : wallet.id);
    const hasCallbackUrl = Boolean(typeof window !== 'undefined' && (callbackUrl === null || callbackUrl === void 0 ? void 0 : callbackUrl.length) > 0);
    if (hasCallbackUrl && isNotBrowserWallet) {
        const { transactionHash } = checkTransactionHash(outcomes);
        let finalUrl = `${callbackUrl}?transactionHashes=${transactionHash}`;
        if (callbackArgs) {
            const args = JSON.stringify({
                type: (_a = callbackArgs === null || callbackArgs === void 0 ? void 0 : callbackArgs.type) !== null && _a !== void 0 ? _a : '',
                args: (_b = callbackArgs === null || callbackArgs === void 0 ? void 0 : callbackArgs.args) !== null && _b !== void 0 ? _b : '',
            });
            const signMeta = encodeURIComponent(args);
            finalUrl = `${callbackUrl}?transactionHashes=${transactionHash}&signMeta=${signMeta}`;
        }
        return window.location.assign(finalUrl);
    }
    return outcomes && outcomes.length == 1 ? outcomes[0] : outcomes;
};
exports.checkCallbackUrl = checkCallbackUrl;
/**
 * checkTransactionHash()
 * check what transaction receipt to return to the user.
 * @param receipt near transaction Receipt object
 * @returns transactionHash object
 */
const checkTransactionHash = (receipt) => {
    var _a, _b, _c, _d, _e;
    let transactionHash = (_a = receipt === null || receipt === void 0 ? void 0 : receipt.transaction_outcome) === null || _a === void 0 ? void 0 : _a.id;
    if ((receipt === null || receipt === void 0 ? void 0 : receipt.length) == 1) {
        transactionHash = (_c = (_b = receipt[0]) === null || _b === void 0 ? void 0 : _b.transaction_outcome) === null || _c === void 0 ? void 0 : _c.id;
    }
    if ((receipt === null || receipt === void 0 ? void 0 : receipt.length) > 1) {
        transactionHash = (_e = (_d = receipt[1]) === null || _d === void 0 ? void 0 : _d.transaction_outcome) === null || _e === void 0 ? void 0 : _e.id;
    }
    return { transactionHash };
};
const callbackUrlFormatter = (callbackUrl, callbackArgs) => {
    let url = callbackUrl && typeof callbackUrl !== 'undefined' ? callbackUrl : null;
    if ((callbackArgs === null || callbackArgs === void 0 ? void 0 : callbackArgs.type) && callbackUrl) {
        const args = JSON.stringify({
            type: callbackArgs === null || callbackArgs === void 0 ? void 0 : callbackArgs.type,
            args: callbackArgs === null || callbackArgs === void 0 ? void 0 : callbackArgs.args,
        });
        const signMeta = encodeURIComponent(args);
        url = `${callbackUrl}/?signMeta=${signMeta}`;
    }
    return url;
};
exports.callbackUrlFormatter = callbackUrlFormatter;
const genericBatchExecute = (call, wallet, account, callbackUrl, callbackArgs) => __awaiter(void 0, void 0, void 0, function* () {
    const url = (0, exports.callbackUrlFormatter)(callbackUrl, callbackArgs);
    if (wallet) {
        return url ? batchExecuteWithBrowserWallet(call, wallet, url) : batchExecuteWithBrowserWallet(call, wallet);
    }
    return batchExecuteWithNearAccount(call, account, url);
});
exports.genericBatchExecute = genericBatchExecute;
// account call translation wrappers https://docs.near.org/tools/near-api-js/faq#how-to-send-batch-transactions
// TODO: share batch signature with wallet selector sendAndSignTransaction when method becomes public
const batchExecuteWithNearAccount = (calls, account, callbackUrl) => __awaiter(void 0, void 0, void 0, function* () {
    const outcomes = [];
    for (const call of calls) {
        try {
            outcomes.push(yield account.functionCall(Object.assign({ contractId: call.contractAddress, methodName: call.methodName, args: call.args, gas: new bn_js_1.default(call.gas), attachedDeposit: new bn_js_1.default(call.deposit) }, (callbackUrl && { walletCallbackUrl: callbackUrl }))));
        }
        catch (err) {
            console.error(`${call.contractAddress}:${call.methodName} in batch failed: ${err}`);
        }
    }
    return outcomes;
});
const batchExecuteWithBrowserWallet = (calls, wallet, callback) => __awaiter(void 0, void 0, void 0, function* () {
    const res = yield wallet.signAndSendTransactions(Object.assign({ transactions: calls.map(exports.convertGenericCallToWalletCall) }, (callback && { callbackUrl: callback })));
    return res;
});
const convertGenericCallToWalletCall = (call) => {
    return {
        signerId: call.signerId,
        receiverId: call.contractAddress,
        actions: [{
                type: 'FunctionCall',
                params: {
                    methodName: call.methodName,
                    args: call.args,
                    gas: call.gas,
                    deposit: call.deposit,
                },
            }],
    };
};
exports.convertGenericCallToWalletCall = convertGenericCallToWalletCall;
function flattenArgs(calls) {
    const contractCalls = [];
    for (const call of calls) {
        if (call instanceof Array && call.length > 0 && call) {
            call.map((item) => contractCalls.push(item));
        }
        else {
            contractCalls.push(call);
        }
    }
    return contractCalls;
}
exports.flattenArgs = flattenArgs;
const validateSigningOptions = ({ wallet, account }) => {
    if (!wallet && !account) {
        throw errors_1.NoSigningMethodPassedError;
    }
};
exports.validateSigningOptions = validateSigningOptions;
//# sourceMappingURL=execute.utils.js.map