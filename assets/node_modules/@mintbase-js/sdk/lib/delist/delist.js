"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.delist = void 0;
const config_1 = require("../config/config");
const constants_1 = require("../constants");
const errorMessages_1 = require("../errorMessages");
const types_1 = require("../types");
/**
 * Delist a token
 * @param args {@link DelistArgs}
 * @returns contract call to be passed to @mintbase-js/sdk execute method
 */
const delist = (args) => {
    const { contractAddress = config_1.mbjs.keys.contractAddress, tokenIds, marketAddress = config_1.mbjs.keys.marketAddress, oldMarket = false } = args;
    if (contractAddress == null) {
        throw new Error(errorMessages_1.ERROR_MESSAGES.CONTRACT_ADDRESS);
    }
    if (!(tokenIds instanceof Array)) {
        throw new Error(errorMessages_1.ERROR_MESSAGES.TOKEN_NOT_ARRAY);
    }
    if (!(tokenIds.length > 0)) {
        throw new Error(errorMessages_1.ERROR_MESSAGES.TOKEN_LENGTH);
    }
    const result = [];
    //revoke ownership for all tokens
    for (const tokenId of tokenIds) {
        result.push({
            contractAddress: contractAddress || config_1.mbjs.keys.marketAddress,
            args: {
                token_id: tokenId,
                account_id: marketAddress || config_1.mbjs.keys.marketAddress,
            },
            methodName: types_1.TOKEN_METHOD_NAMES.TOKEN_ACCOUNT_REVOKE,
            gas: constants_1.GAS,
            deposit: constants_1.ONE_YOCTO,
        });
    }
    result.push({
        contractAddress: marketAddress || config_1.mbjs.keys.marketAddress,
        methodName: oldMarket ? types_1.MARKET_METHOD_NAMES.UNLIST_OLD_MARKET : types_1.MARKET_METHOD_NAMES.UNLIST,
        args: {
            token_ids: tokenIds,
            nft_contract_id: contractAddress || config_1.mbjs.keys.marketAddress,
        },
        gas: constants_1.GAS,
        deposit: constants_1.ONE_YOCTO,
    });
    return result;
};
exports.delist = delist;
//# sourceMappingURL=delist.js.map