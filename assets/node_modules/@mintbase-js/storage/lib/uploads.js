"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFormDataFromJson = exports.getFileFromObject = exports.uploadReference = exports.uploadFile = exports.uploadBuffer = void 0;
const constants_1 = require("./constants");
const sdk_1 = require("@mintbase-js/sdk");
const superagent_1 = __importDefault(require("superagent"));
/**
 * (NodeJS) upload a file via POST to upload service
 * @param file A file to upload
 * @param name The name of the file to upload
 */
const uploadBuffer = (file, name) => __awaiter(void 0, void 0, void 0, function* () {
    if (sdk_1.mbjs.keys.apiKey == constants_1.MINTBASE_API_ANON_USER) {
        console.warn(constants_1.ANON_USER_WARNING);
    }
    const size = file.length;
    // if size is more than 30MB, throw since cloud run won't upload.
    if (size > constants_1.MAX_UPLOAD_BYTES) {
        throw new Error(constants_1.MAX_UPLOAD_ERROR_MSG);
    }
    try {
        const { body } = yield superagent_1.default
            .post(constants_1.ARWEAVE_SERVICE_HOST)
            .set({
            [constants_1.MINTBASE_API_KEY_HEADER]: sdk_1.mbjs.keys.apiKey,
        })
            .attach('file', file, name);
        return body;
    }
    catch (err) {
        const httpError = err;
        console.error(`Uploading file to arweave failed: ${httpError.status} ${httpError.response.text}`);
        throw err;
    }
});
exports.uploadBuffer = uploadBuffer;
/**
 * (Browser) upload a file via POST to upload service
 * @param file A file to upload
 */
const uploadFile = (file) => __awaiter(void 0, void 0, void 0, function* () {
    if (sdk_1.mbjs.keys.apiKey == constants_1.MINTBASE_API_ANON_USER) {
        console.warn(constants_1.ANON_USER_WARNING);
    }
    if (file.size > constants_1.MAX_UPLOAD_BYTES) {
        throw new Error(constants_1.MAX_UPLOAD_ERROR_MSG);
    }
    const formData = new FormData();
    formData.append('file', file, 'file');
    try {
        const request = yield fetch(constants_1.ARWEAVE_SERVICE_HOST, {
            method: 'POST',
            headers: {
                [constants_1.MINTBASE_API_KEY_HEADER]: sdk_1.mbjs.keys.apiKey,
            },
            body: formData,
            redirect: 'follow',
        });
        if (request.status !== 200) {
            throw new Error(`Error uploading via arweave service: ${yield request.json()}`);
        }
        const result = (yield request.json());
        return result;
    }
    catch (error) {
        console.error('Uploading file to arweave failed');
        throw error;
    }
});
exports.uploadFile = uploadFile;
/**
 * (Browser) upload a json reference object via POST to upload service
 * @param ReferenceObject A json reference object to upload
 */
const uploadReference = (referenceObject) => __awaiter(void 0, void 0, void 0, function* () {
    if (Object.keys(referenceObject).length == 0) {
        throw new Error(constants_1.OBJECT_IS_EMPTY_ERROR);
    }
    const formData = getFormDataFromJson(referenceObject);
    try {
        const request = yield fetch(`${constants_1.ARWEAVE_SERVICE_HOST}/reference`, {
            method: 'POST',
            headers: {
                'mb-api-key': sdk_1.mbjs.keys.apiKey,
            },
            body: formData,
            redirect: 'follow',
        });
        if (request.status !== 200) {
            throw new Error(`Error uploading via arweave service: ${yield request.json()}`);
        }
        const result = (yield request.json());
        return result;
    }
    catch (error) {
        console.error('Uploading file to arweave failed');
        throw error;
    }
});
exports.uploadReference = uploadReference;
function getFileFromObject(referenceObject) {
    const str = JSON.stringify(referenceObject);
    return new File([str], 'file', {
        type: 'application/json;charset=utf-8',
    });
}
exports.getFileFromObject = getFileFromObject;
function getFormDataFromJson(referenceObject) {
    const formData = new FormData();
    Object.entries(referenceObject).forEach((entry) => {
        const [key, value] = entry;
        const hasCorrectMediaType = (key == 'document' || key == 'media' || key == 'animation_url');
        const notMedia = !hasCorrectMediaType && !(value instanceof File);
        const canBeUploaded = value instanceof File && value.size < constants_1.MAX_UPLOAD_BYTES;
        const invalidFile = !hasCorrectMediaType && (value instanceof File);
        const mediaTypeWithoutFile = hasCorrectMediaType && (typeof (value) == 'string');
        if (invalidFile) {
            // example title: File
            throw new Error('The provided field has a key that is not recognized by our service and will not be uploaded to arweave, try using media, animation_url or document');
        }
        if (mediaTypeWithoutFile) {
            // example: media: ""  -> upload anyways
            console.warn('The provided media type will not be uploaded because its a string and not a file, try attaching files to the following keys: media, animation_url or document');
            formData.append(key, value);
        }
        if (notMedia && typeof (value) == 'string') {
            //fields
            formData.append(key, value);
        }
        else if (canBeUploaded) {
            //media
            formData.append(key, value);
        }
    });
    return formData;
}
exports.getFormDataFromJson = getFormDataFromJson;
//# sourceMappingURL=uploads.js.map